package xarxa:api@0.3.1;

world orchestrator {
    export workflow-ctrl;

    import custom-http;
    import host-controller;
    import logger;
    
}

interface workflow-ctrl {
    use engine-types.{kvpair, workflow-run, workflow-error, run-id};

    start-workflow: func(workflow-name: string, input: list<u8>) -> result<workflow-run, workflow-error>;
    continue-workflow: func(id: run-id, state: list<u8>) -> result<list<u8>, workflow-error>;

    // resource workflow-engine {
    //     constructor();
    //     /// Start a new workflow from scratch. Passes the name of the workflow and input data. 
    //     /// The history here is always empty.
    //     start-workflow: func(workflow-name: string, input: list<kvpair>) -> result<workflow-run, workflow-error>;

    //     /// Continue to execute a “asleep” workflow. This is the most frequent command.
    //     /// Transfers the entire event history so that SDK can execute replay.
    //     continue-workflow: func(id: run-id, history: history) -> result<string, workflow-error>;

    //     /// Execute a specific function-activity. Passes the name of the activity and its input data. 
    //     /// This command is “dumb”, it does not deal with the replay logic.
    //     execute-activity: func(activity-name: string, input: list<kvpair>) -> result<string, string>;

    //     /// “Push” the signal into the workflow. Passes the name of the signal and its payload.
    //     signal-workflow: func(id: run-id, signal: signal) -> result<string, workflow-error>;

    //     /// Notify the running workflow of a cancel request.
    //     /// This is essentially just sending a predefined internal __cancel signal.
    //     cancel-workflow: func(id: run-id) -> result<string, workflow-error>;
    // }

    // create-workflow-engine: func() -> workflow-engine;
}

interface host-controller {
    use engine-types.{run-id};

    send-result: func(id: run-id, data: list<u8>);
}

interface custom-http {
    use http-types.{header, method};

    http-request: func(headers: list<header>, method: method, url: string, body: list<u8>) -> result<list<u8>, string>;
}

interface logger {
    use engine-types.{run-id};

    logging: func(msg: list<u8>);
}

interface http-types {
    enum method {
        get,
        post,
    }

    record header {
        key: string,
        value: string,
    }
}

interface engine-types {
    variant value {
        none,
        str(string),
        int64(s64),
        uint64(u64),
        float64(f64),
        boolean(bool),
        any(list<u8>),
    }

    record kvpair {
        key: string,
        value: value,
    }

    type run-id = u64;

    type unixtime = u64;

    record workflow-run {
        id: run-id,
        input: list<kvpair>,
        timestamp: unixtime,
    }

    enum code {
        not-found,
        empty-input,
    }

    record workflow-error {
        err: string,
        code: code,
    }
}